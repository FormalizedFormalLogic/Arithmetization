import Arithmetization.Lemmata
import Arithmetization.Vorspiel.Graph
import Logic.FirstOrder.Arith.StrictHierarchy
import Aesop

lemma Matrix.succ_pred {n : ‚Ñï} (P : Fin n.succ ‚Üí Prop) : (‚àÄ i, P i) ‚Üî (P 0 ‚àß ‚àÄ i : Fin n, P i.succ) :=
  ‚ü®fun h ‚Ü¶ ‚ü®h 0, fun i ‚Ü¶ h i.succ‚ü©, fun h ‚Ü¶ Fin.cases h.1 h.2‚ü©

namespace LO.FirstOrder

namespace Arith

section

variable {L : Language} [L.Eq] [L.LT] (Œæ : Type*) [DecidableEq Œæ]

abbrev HClassInWithEq (Œì s) (T : Theory L) := HClassIn Œæ Œì s (T + ùêÑùê™)

abbrev DeltaZeroInWithEq (T : Theory L) := DeltaZeroIn Œæ (T + ùêÑùê™)

notation Œì "·¥¥("s")[" T "]" => HClassInWithEq _ Œì s T

notation "Œî‚ÇÄ[" T "]" => DeltaZeroInWithEq _ T

end

namespace Definability

variable {T : Theory ‚Ñí‚Çí·µ£}

structure DeltaZeroRelation (T : Theory ‚Ñí‚Çí·µ£) (k : ‚Ñï) where
  definition : Semisentence ‚Ñí‚Çí·µ£ k
  definition_deltaZero : Œî‚ÇÄ[T].Domain definition

namespace DeltaZeroRelation

def eq : DeltaZeroRelation T 2 := ‚ü®‚Äú#0 = #1‚Äù, by simp‚ü©

def lt : DeltaZeroRelation T 2 := ‚ü®‚Äú#0 < #1‚Äù, by simp‚ü©

def le : DeltaZeroRelation T 2 := ‚ü®‚Äú#0 ‚â§ #1‚Äù, by simp‚ü©

variable {M : Type*} [Structure ‚Ñí‚Çí·µ£ M]

abbrev eval (p : DeltaZeroRelation T k) (v : Fin k ‚Üí M) : Prop :=
  Semiformula.PVal! M v p.definition

end DeltaZeroRelation

structure DeltaZeroFunction (T : Theory ‚Ñí‚Çí·µ£) (k : ‚Ñï) where
  charactor : DeltaZeroRelation T (k + 1)
  total : T + ùêÑùê™ ‚ä¢! ‚àÄ* ‚àÉ! charactor.definition

namespace DeltaZeroFunction

def polynomial {k} (t : Polynomial k) : DeltaZeroFunction T k where
  charactor := ‚ü®‚Äú#0 = !!(Rew.bShift t)‚Äù, by simp‚ü©
  total := Complete.consequence_iff_provable.mp
    <| oRing_consequence_of _ _ <| fun M _ _ _ _ _ _ => by simp [models_iff]

abbrev definition (f : DeltaZeroFunction T k) : Semisentence ‚Ñí‚Çí·µ£ (k + 1) := f.charactor.definition

lemma polynomial_definition {k} (t : Polynomial k) :
    (polynomial t : DeltaZeroFunction T k).definition = ‚Äú#0 = !!(Rew.bShift t)‚Äù := rfl

def zero : DeltaZeroFunction T 0 := polynomial ·µÄ‚Äú0‚Äù

def one : DeltaZeroFunction T 0 := polynomial ·µÄ‚Äú1‚Äù

def add : DeltaZeroFunction T 2 := polynomial ·µÄ‚Äú#0 + #1‚Äù

def mul : DeltaZeroFunction T 2 := polynomial ·µÄ‚Äú#0 * #1‚Äù

section realize

variable {M : Type} [Zero M] [One M] [Add M] [Mul M] [LT M] [T.Mod M]

lemma realize_exists_unique (f : DeltaZeroFunction T k) (v : Fin k ‚Üí M) : ‚àÉ! y, Semiformula.PVal! M (y :> v) f.definition := by
  have : ‚àÄ e, ‚àÉ! x, (Semiformula.PVal! M (x :> e)) f.definition := by simpa [models_iff] using oring_sound M f.total
  exact this v

noncomputable def realize (f : DeltaZeroFunction T k) (v : Fin k ‚Üí M) : M := Classical.choose! (realize_exists_unique f v)

lemma realize_graph {f : DeltaZeroFunction T k} {y : M} {v : Fin k ‚Üí M} :
    y = f.realize v ‚Üî Semiformula.PVal! M (y :> v) f.definition :=
  Classical.choose!_eq_iff (x := y) <| realize_exists_unique f v

lemma realize_eq_of {f : DeltaZeroFunction T k} {y : M} {v : Fin k ‚Üí M}
    (H : Semiformula.PVal! M (y :> v) f.definition) : f.realize v = y :=
  Eq.symm <| realize_graph.mpr H

lemma pval_realize_definition (f : DeltaZeroFunction T k) (v : Fin k ‚Üí M) :
    Semiformula.PVal! M (f.realize v :> v) f.definition := realize_graph.mp rfl

@[simp] lemma zero_realize : (zero : DeltaZeroFunction T 0).realize ![] = (0 : M) :=
  DeltaZeroFunction.realize_eq_of (by simp [zero, polynomial_definition])

@[simp] lemma one_realize : (one : DeltaZeroFunction T 0).realize ![] = (1 : M) :=
  DeltaZeroFunction.realize_eq_of (by simp [one, polynomial_definition])

@[simp] lemma add_realize (a b : M) : (add : DeltaZeroFunction T 2).realize ![a, b] = a + b :=
  DeltaZeroFunction.realize_eq_of (by simp [add, polynomial_definition])

@[simp] lemma mul_realize (a b : M) : (mul : DeltaZeroFunction T 2).realize ![a, b] = a * b :=
  DeltaZeroFunction.realize_eq_of (by simp [mul, polynomial_definition])

end realize

end DeltaZeroFunction

structure BoundedDeltaZeroFunction (T : Theory ‚Ñí‚Çí·µ£) (k : ‚Ñï) where
  function : DeltaZeroFunction T k
  bound : Polynomial k
  bounded : T + ùêèùêÄ‚Åª + ùêÑùê™ ‚ä¢! ‚àÄ* (function.definition ‚ü∂ ‚Äú#0 ‚â§ !!(Rew.bShift bound)‚Äù)

namespace BoundedDeltaZeroFunction

def polynomial {k} (t : Polynomial k) : BoundedDeltaZeroFunction T k where
  function := DeltaZeroFunction.polynomial t
  bound := t
  bounded := Complete.consequence_iff_provable.mp
    <| oRing_consequence_of _ _ <| fun M _ _ _ _ _ _ => by
      haveI : T.Mod M := Theory.Mod.of_ss M (T‚ÇÅ := T + ùêèùêÄ‚Åª + ùêÑùê™) (by simp [Theory.add_def])
      haveI : ùêèùêÄ‚Åª.Mod M := Theory.Mod.of_ss M (T‚ÇÅ := T + ùêèùêÄ‚Åª + ùêÑùê™) (by simp [Theory.add_def])
      simp [models_iff, DeltaZeroFunction.polynomial_definition, Semiterm.val_bShift']
      intro v e; simp [e]

def zero : BoundedDeltaZeroFunction T 0 := polynomial ·µÄ‚Äú0‚Äù

def one : BoundedDeltaZeroFunction T 0 := polynomial ·µÄ‚Äú1‚Äù

def add : BoundedDeltaZeroFunction T 2 := polynomial ·µÄ‚Äú#0 + #1‚Äù

def mul : BoundedDeltaZeroFunction T 2 := polynomial ·µÄ‚Äú#0 * #1‚Äù

section realize

variable {M : Type} [Zero M] [One M] [Add M] [Mul M] [LT M] [T.Mod M]

noncomputable abbrev realize (f : BoundedDeltaZeroFunction T k) (v : Fin k ‚Üí M) := f.function.realize v

@[simp] lemma zero_realize : (zero : BoundedDeltaZeroFunction T 0).realize ![] = (0 : M) :=
  Eq.trans rfl DeltaZeroFunction.zero_realize

@[simp] lemma one_realize : (one : BoundedDeltaZeroFunction T 0).realize ![] = (1 : M) :=
  Eq.trans rfl DeltaZeroFunction.one_realize

@[simp] lemma add_realize (a b : M) : (add : BoundedDeltaZeroFunction T 2).realize ![a, b] = a + b :=
  Eq.trans rfl (DeltaZeroFunction.add_realize a b)

@[simp] lemma mul_realize (a b : M) : (mul : BoundedDeltaZeroFunction T 2).realize ![a, b] = a * b :=
  Eq.trans rfl (DeltaZeroFunction.mul_realize a b)

variable [ùêèùêÄ‚Åª.Mod M]

lemma realize_le_bound (f : BoundedDeltaZeroFunction T k) (v : Fin k ‚Üí M) :
    f.realize v ‚â§ Semiterm.bVal! M v f.bound := by
  have : ‚àÄ v : Fin (k + 1) ‚Üí M,
      (Semiformula.PVal! M v) f.function.definition ‚Üí v 0 ‚â§ Semiterm.bVal! M (v ¬∑.succ) f.bound := by
    simpa [models_def, Semiterm.val_bShift'] using oring_sound M f.bounded
  simpa using this (f.function.realize v :> v) (DeltaZeroFunction.pval_realize_definition _ _)

end realize

end BoundedDeltaZeroFunction

def boundedLanguage (T : Theory ‚Ñí‚Çí·µ£) : Language where
  Func := BoundedDeltaZeroFunction T
  Rel := DeltaZeroRelation T

notation "‚Ñí‚Çí·µ£[" T "]" => boundedLanguage T

namespace boundedLanguage

def _root_.LO.FirstOrder.Arith.Definition.BoundedDeltaZeroFunction.toFunc {k} (f : BoundedDeltaZeroFunction T k) : ‚Ñí‚Çí·µ£[T].Func k := f

def _root_.LO.FirstOrder.Arith.FormulaHierarchy.toRel {k} (r : DeltaZeroRelation T k) : ‚Ñí‚Çí·µ£[T].Rel k := r

instance : Language.Eq ‚Ñí‚Çí·µ£[T] := ‚ü®DeltaZeroRelation.eq‚ü©

instance : Language.LT ‚Ñí‚Çí·µ£[T] := ‚ü®DeltaZeroRelation.lt‚ü©

instance : Language.Zero ‚Ñí‚Çí·µ£[T] := ‚ü®BoundedDeltaZeroFunction.zero‚ü©

instance : Language.One ‚Ñí‚Çí·µ£[T] := ‚ü®BoundedDeltaZeroFunction.one‚ü©

instance : Language.Add ‚Ñí‚Çí·µ£[T] := ‚ü®BoundedDeltaZeroFunction.add‚ü©

instance : Language.Mul ‚Ñí‚Çí·µ£[T] := ‚ü®BoundedDeltaZeroFunction.mul‚ü©

instance : Language.ORing ‚Ñí‚Çí·µ£[T] where

def polybound {n : ‚Ñï} : Semiterm ‚Ñí‚Çí·µ£[T] Œæ n ‚Üí Semiterm ‚Ñí‚Çí·µ£ Œæ n
  | #x                => #x
  | &x                => &x
  | Semiterm.func f v => Rew.embSubsts (fun i ‚Ü¶ polybound (v i)) f.bound

lemma polybound_positive {t : Semiterm ‚Ñí‚Çí·µ£[T] Œæ (n + 1)} :
    t.Positive ‚Üí (polybound t).Positive := by
  induction t <;> simp [polybound, *]
  case func t v ih =>
    intro h i _; exact ih i (h i)

lemma polybound_bShift (t : Semiterm ‚Ñí‚Çí·µ£[T] Œæ n) :
    polybound (Rew.bShift t) = Rew.bShift (polybound t) := by
  induction t <;> simp [polybound]
  case func f v ih =>
    show (Rew.embSubsts fun i => polybound (Rew.bShift (v i))) f.bound =
      Rew.bShift ((Rew.embSubsts fun i => polybound (v i)) f.bound)
    simp [ih, ‚ÜêRew.comp_app]; congr 1
    ext <;> simp [Rew.comp_app]; { contradiction }

variable (T)

inductive Denotation : ‚Ñï ‚Üí Type
  | var {n} : Fin n ‚Üí Denotation n
  | comp {arity n : ‚Ñï} :
    DeltaZeroRelation T (arity + 1) ‚Üí (Fin arity ‚Üí Denotation n) ‚Üí (Fin arity ‚Üí Polynomial n) ‚Üí Denotation n

variable {T}

namespace Denotation

def bShift : Denotation T n ‚Üí Denotation T (n + 1)
  | var x      => var x.succ
  | comp p v t => comp p (fun i ‚Ü¶ bShift (v i)) (fun i ‚Ü¶ Rew.bShift (t i))

def toFormula : Denotation T n ‚Üí Semisentence ‚Ñí‚Çí·µ£ (n + 1)
  | var x                   => ‚Äú#0 = !!#x.succ‚Äù
  | comp (arity := k) p v b =>
      Rew.toS.hom
        <| bexClosure (fun i ‚Ü¶ ‚Äú#0 < !!(Rew.bShift $ Rew.toF $ Rew.bShift $ b i) + 1‚Äù)
        <| (Matrix.conj fun i : Fin k ‚Ü¶ (Rew.embSubsts (#i :> (& ¬∑.succ))).hom (v i).toFormula) ‚ãè (Rew.embSubsts (&0 :> (# ¬∑))).hom p.definition

def ofTerm : Semiterm ‚Ñí‚Çí·µ£[T] Empty n ‚Üí Denotation T n
  | #x                                                 => var x
  | Semiterm.func (f : BoundedDeltaZeroFunction T _) v =>
      comp f.function.charactor (fun i ‚Ü¶ ofTerm (v i)) (fun i ‚Ü¶ polybound (v i))

def atom {k n} (p : DeltaZeroRelation T k) (v : Fin k ‚Üí Semiterm ‚Ñí‚Çí·µ£[T] Empty n) : Semisentence ‚Ñí‚Çí·µ£ n :=
  Rew.toS.hom
    <| bexClosure (fun i ‚Ü¶ ‚Äú#0 < !!(Rew.bShift $ Rew.toF $ polybound (v i)) + 1‚Äù)
      <| (Matrix.conj fun i : Fin k ‚Ü¶ (Rew.embSubsts (#i :> (& ¬∑))).hom (ofTerm $ v i).toFormula) ‚ãè Rew.emb.hom p.definition

lemma toFormula_deltaZero (d : Denotation T n) : Œî‚ÇÄ[T].Domain d.toFormula := by
  induction d <;> simp [Denotation.toFormula]
  case comp p d t IH =>
    exact HClassIn.rew
      (Class.bexClosure (by simp)
        (Class.And.and (Class.matrix_conj fun j ‚Ü¶ HClassIn.rew (IH j) _) (HClassIn.rew p.definition_deltaZero _))) _

lemma atom_deltaZero {k n} (p : DeltaZeroRelation T k) (v : Fin k ‚Üí Semiterm ‚Ñí‚Çí·µ£[T] Empty n) :
    Œî‚ÇÄ[T].Domain (Denotation.atom p v) := by
  simp [Denotation.atom]
  exact HClassIn.rew (Class.bexClosure (by simp)
    <| Class.And.and (Class.matrix_conj fun _ ‚Ü¶ HClassIn.rew (toFormula_deltaZero _) _) (HClassIn.rew p.definition_deltaZero _)) _

end Denotation

def arithmetizeAux {n : ‚Ñï} : Semisentence ‚Ñí‚Çí·µ£[T] n ‚Üí Semisentence ‚Ñí‚Çí·µ£ n
  | Semiformula.rel (p : DeltaZeroRelation T _) v  => Denotation.atom p v
  | Semiformula.nrel (p : DeltaZeroRelation T _) v => ~Denotation.atom p v
  | ‚ä§                                => ‚ä§
  | ‚ä•                                => ‚ä•
  | p ‚ãè q                            => arithmetizeAux p ‚ãè arithmetizeAux q
  | p ‚ãé q                            => arithmetizeAux p ‚ãé arithmetizeAux q
  | ‚àÄ' p                             => ‚àÄ' arithmetizeAux p
  | ‚àÉ' p                             => ‚àÉ' arithmetizeAux p

lemma arithmetize_aux_not_not (p : Semisentence ‚Ñí‚Çí·µ£[T] n) : arithmetizeAux (~p) = ~arithmetizeAux p := by
  induction p using Semiformula.rec' <;> simp [arithmetizeAux, ‚ÜêSemiformula.neg_eq, *]

def arithmetize : Semisentence ‚Ñí‚Çí·µ£[T] n ‚ÜíÀ°·∂ú Semisentence ‚Ñí‚Çí·µ£ n where
  toTr := arithmetizeAux
  map_top' := rfl
  map_bot' := rfl
  map_and' := fun _ _ ‚Ü¶ rfl
  map_or' := fun _ _ ‚Ü¶ rfl
  map_neg' := fun _ ‚Ü¶ by simp [arithmetize_aux_not_not]
  map_imply' := fun _ _ ‚Ü¶ by simp [Semiformula.imp_eq, ‚ÜêSemiformula.neg_eq, arithmetizeAux, arithmetize_aux_not_not]

@[simp] lemma arithmetize_rel {k} (p : DeltaZeroRelation T k) (v : Fin k ‚Üí Semiterm ‚Ñí‚Çí·µ£[T] Empty n) :
    arithmetize (Semiformula.rel p v) = Denotation.atom p v := rfl

@[simp] lemma arithmetize_nrel {k} (p : DeltaZeroRelation T k) (v : Fin k ‚Üí Semiterm ‚Ñí‚Çí·µ£[T] Empty n) :
    arithmetize (Semiformula.nrel p v) = ~Denotation.atom p v := rfl

@[simp] lemma arithmetize_all (p : Semisentence ‚Ñí‚Çí·µ£[T] (n + 1)) : arithmetize (‚àÄ' p) = ‚àÄ' arithmetize p := rfl

@[simp] lemma arithmetize_ex (p : Semisentence ‚Ñí‚Çí·µ£[T] (n + 1)) : arithmetize (‚àÉ' p) = ‚àÉ' arithmetize p := rfl

/-
lemma arithmetize_hierarsssschy {p : Semisentence ‚Ñí‚Çí·µ£[T] n} (hp : Hierarchy b s p) :
    Hierarchy b s (arithmetize p) := by {
  induction p using Semiformula.rec' <;> simp [*]
  case hand ihp ihq => simp at hp; exact ‚ü®ihp hp.1, ihq hp.2‚ü©
  case hor ihp ihq => simp at hp; exact ‚ü®ihp hp.1, ihq hp.2‚ü©
  case hall ih =>
    have := ih hp.remove_forall
   }

lemma arithmetize_hierarchy (p : Semisentence ‚Ñí‚Çí·µ£[T] n) :
    Hierarchy b s (arithmetize p) ‚Üî Hierarchy b s p := by {
  induction p using Semiformula.rec' <;> simp [*]
   }
-/

section semantics

variable {M : Type} [Zero M] [One M] [Add M] [Mul M] [LT M] [T.Mod M]

noncomputable instance semantics : Structure ‚Ñí‚Çí·µ£[T] M where
  func := fun k (f : BoundedDeltaZeroFunction T k) v ‚Ü¶ f.function.realize v
  rel := fun k (p : DeltaZeroRelation T k) v ‚Ü¶ p.eval v

@[simp] lemma semantics_func {k} (f : BoundedDeltaZeroFunction T k) (v : Fin k ‚Üí M) :
    semantics.func f v = f.function.realize v := rfl

@[simp] lemma semantics_rel {k} (p : DeltaZeroRelation T k) (v : Fin k ‚Üí M) :
    semantics.rel (L := ‚Ñí‚Çí·µ£[T]) p v ‚Üî p.eval v := iff_of_eq rfl

instance : Structure.Zero ‚Ñí‚Çí·µ£[T] M :=
  ‚ü®by simp[Semiterm.Operator.val, Semiterm.Operator.Zero.zero, Language.Zero.zero]‚ü©

instance : Structure.One ‚Ñí‚Çí·µ£[T] M :=
  ‚ü®by simp[Semiterm.Operator.val, Semiterm.Operator.One.one, Language.One.one]‚ü©

instance : Structure.Add ‚Ñí‚Çí·µ£[T] M :=
  ‚ü®by intro a b; simp[Semiterm.Operator.val, Semiterm.val_func, Semiterm.Operator.Add.add, Language.Add.add]‚ü©

instance : Structure.Mul ‚Ñí‚Çí·µ£[T] M :=
  ‚ü®by intro a b; simp[Semiterm.Operator.val, Semiterm.val_func, Semiterm.Operator.Mul.mul, Language.Mul.mul]‚ü©

instance : Structure.Eq ‚Ñí‚Çí·µ£[T] M :=
  ‚ü®by intro a b
      simp[DeltaZeroRelation.eval, Semiformula.Operator.val,
        Semiformula.Operator.Eq.sentence_eq, Semiformula.eval_rel, Language.Eq.eq]
      simp [DeltaZeroRelation.eq]‚ü©

instance : Structure.LT ‚Ñí‚Çí·µ£[T] M :=
  ‚ü®by intro a b
      simp [DeltaZeroRelation.eval, Semiformula.Operator.val, Semiformula.Operator.LT.sentence_eq, Semiformula.eval_rel, Language.LT.lt]
      simp [DeltaZeroRelation.lt]‚ü©

variable [ùêèùêÄ‚Åª.Mod M]

lemma le_bound (t : Semiterm ‚Ñí‚Çí·µ£[T] Œæ n) (Œµ v) :
    Semiterm.val! M v Œµ t ‚â§ Semiterm.val! M v Œµ (polybound t) := by
  induction t
  case bvar => simp [polybound]
  case fvar => simp [polybound]
  case func f v IH =>
    simp [Semiterm.val_func, polybound, Semiterm.val_embSubsts]
    exact le_trans (f.realize_le_bound _) (Model.polynomial_mono _ IH (by simp))

lemma pval_of_term_to_formula {t : Semiterm ‚Ñí‚Çí·µ£[T] Empty n} {y : M} {v} :
    Semiformula.PVal! M (y :> v) (Denotation.ofTerm t).toFormula ‚Üî y = Semiterm.bVal! M v t := by
  induction t generalizing y v <;> try simp [Denotation.ofTerm, Denotation.toFormula, Model.lt_succ_iff_le]
  case fvar x =>
    contradiction
  case func f w IH =>
    simp [Denotation.toFormula, Matrix.succ_pred, Matrix.comp_vecCons', Semiterm.val_func, DeltaZeroFunction.realize_graph, IH]
    constructor
    ¬∑ rintro ‚ü®e, _, he, H‚ü©
      rcases show e = fun x ‚Ü¶ Semiterm.bVal! M v (w x) from funext he
      exact H
    ¬∑ intro H
      exact ‚ü®fun x ‚Ü¶ Semiterm.bVal! M v (w x), fun i ‚Ü¶ le_bound (w i) _ _, fun i ‚Ü¶ rfl, H‚ü©

lemma pval_atom_iff {k n} (e : Fin n ‚Üí M) (p : DeltaZeroRelation T k) (v : Fin k ‚Üí Semiterm ‚Ñí‚Çí·µ£[T] Empty n) :
    Semiformula.PVal! M e (Denotation.atom p v) ‚Üî p.eval fun i => (v i).bVal! M e := by
  simp [Denotation.atom, Denotation.toFormula, Model.lt_succ_iff_le]
  constructor
  ¬∑ rintro ‚ü®w, bw, hw, H‚ü©
    suffices w = fun i ‚Ü¶ (v i).bVal! M e by
      rcases this; exact H
    funext i
    exact pval_of_term_to_formula.mp (hw i)
  ¬∑ intro H
    exact ‚ü®fun i ‚Ü¶ (v i).bVal! M e, fun i ‚Ü¶ by simp [le_bound], fun i ‚Ü¶ pval_of_term_to_formula.mpr (by simp), H‚ü©

@[simp] lemma arithmetize_iff {n} (v : Fin n ‚Üí M) (p : Semisentence ‚Ñí‚Çí·µ£[T] n) :
    Semiformula.PVal! M v (arithmetize p) ‚Üî Semiformula.PVal! M v p := by
  induction p using Semiformula.rec' <;> try simp [*, Semiformula.eval_rel, Semiformula.eval_nrel, pval_atom_iff]

end semantics

section hierarchy

abbrev HClassInBL (Œæ : Type*) [DecidableEq Œæ] (Œì : Polarity) (s : ‚Ñï) (T : Theory ‚Ñí‚Çí·µ£) : Class ‚Ñí‚Çí·µ£[T] Œæ :=
    HClassIn Œæ Œì s (T.lMap Language.oringEmb + ùêÑùê™)

abbrev DeltaZeroInBL (Œæ : Type*) [DecidableEq Œæ] (T : Theory ‚Ñí‚Çí·µ£) : Class ‚Ñí‚Çí·µ£[T] Œæ :=
    HClassInBL Œæ Œ£ 0 T

notation Œì "·¥¥'("s")[" T "]" => HClassInBL _ Œì s T

notation "Œî‚ÇÄ'[" T "]" => DeltaZeroInBL _ T

namespace HClassInBL

variable {T : Theory ‚Ñí‚Çí·µ£} [ùêÑùê™ ‚âæ T] [ùêèùêÄ‚Åª ‚âæ T] {Œæ : Type*} [DecidableEq Œæ]

@[formula_class] lemma ball_le {n} {p : Semiformula ‚Ñí‚Çí·µ£[T] Œæ (n + 1)} {t} (hp : (HClassInBL Œæ Œì s T).Domain p) (ht : t.Positive) :
    (HClassInBL Œæ Œì s T).Domain (‚àÄ[‚Äú#0 ‚â§ !!t‚Äù] p) := by
  have : (HClassInBL Œæ Œì s T).Domain (‚àÄ[‚Äú#0 < !!t + 1‚Äù] p) := Class.BAll.ball hp (by simp [ht])
  exact Class.domain_eqvClosure this (by
    unfold Semiformula.Equivalent
    apply consequence_of
    intro M _ _ _ _ _ _ _ instMod
    haveI : T.Mod M := (mod_lMap_oringEmb T).mp (@Theory.Mod.of_add_left _ M _ _ _ _ instMod)
    haveI : ùêèùêÄ‚Åª.Mod M := Theory.Mod.of_provably_subtheory' M ùêèùêÄ‚Åª T
    simp [models_iff, Model.le_iff_lt_succ])

@[formula_class] lemma bex_le {n} {p : Semiformula ‚Ñí‚Çí·µ£[T] Œæ (n + 1)} {t} (hp : (HClassInBL Œæ Œì s T).Domain p) (ht : t.Positive) :
    (HClassInBL Œæ Œì s T).Domain (‚àÉ[‚Äú#0 ‚â§ !!t‚Äù] p) := by
  have : (HClassInBL Œæ Œì s T).Domain (‚àÉ[‚Äú#0 < !!t + 1‚Äù] p) := Class.BEx.bex hp (by simp [ht])
  exact Class.domain_eqvClosure this (by
    apply consequence_of
    intro M _ _ _ _ _ _ _ instMod
    haveI : T.Mod M := (mod_lMap_oringEmb T).mp (@Theory.Mod.of_add_left _ M _ _ _ _ instMod)
    haveI : ùêèùêÄ‚Åª.Mod M := Theory.Mod.of_provably_subtheory' M ùêèùêÄ‚Åª T
    simp [models_iff, Model.le_iff_lt_succ])

end HClassInBL

example : (Œî‚ÇÄ'[ùêèùêÄ‚Åª] : Class ‚Ñí‚Çí·µ£[ùêèùêÄ‚Åª] ‚Ñï).Domain (‚Äú‚àÄ[#0 ‚â§ 5] !(Rew.bShift.hom ‚Äú0 < #3‚Äù)‚Äù : Semiformula ‚Ñí‚Çí·µ£[ùêèùêÄ‚Åª] ‚Ñï 8) := by
  formula_class

end hierarchy

variable {T : Theory ‚Ñí‚Çí·µ£} [ùêèùêÄ‚Åª ‚âæ T]

lemma arithmetize_lt_deltaZero (t u : Semiterm ‚Ñí‚Çí·µ£[T] Empty n) :
    Œî‚ÇÄ[T].Domain (arithmetize ‚Äú!!t < !!u‚Äù) := by
  simp [Semiformula.Operator.operator, Semiformula.Operator.LT.sentence_eq, Rew.rel]
  exact Denotation.atom_deltaZero _ _

lemma arithmetize_le_deltaZero (t u : Semiterm ‚Ñí‚Çí·µ£[T] Empty n) :
    Œî‚ÇÄ[T].Domain (arithmetize ‚Äú!!t ‚â§ !!u‚Äù) := by
  simp [Semiformula.Operator.operator, Semiformula.Operator.Eq.sentence_eq,
    Semiformula.Operator.LT.sentence_eq, Semiformula.Operator.LE.sentence_eq, Rew.rel]
  exact Class.Or.or (Denotation.atom_deltaZero _ _) (Denotation.atom_deltaZero _ _)

lemma arithmetize_hClassIn_of_hierarchy {p : Semisentence ‚Ñí‚Çí·µ£[T] n} (hp : Hierarchy Œì s p) :
    Œì·¥¥(s)[T].Domain (arithmetize p) := by
  induction hp <;> try simp
  case rel p v =>
    exact HClassIn.of_deltaZeroIn (Denotation.atom_deltaZero p v)
  case nrel p v =>
    exact HClassIn.of_deltaZeroIn (Class.Not.not $ Denotation.atom_deltaZero p v)
  case and ihp ihq => exact Class.And.and ihp ihq
  case or ihp ihq => exact Class.Or.or ihp ihq
  case ball p t ht _ ih =>
    have : arithmetize ‚Äú‚àÄ[#0 < !!t] !p‚Äù ‚Üî[T + ùêÑùê™] (‚àÄ[‚Äú#0 < !!(polybound t)‚Äù] (arithmetize (‚Äú!!t ‚â§ #0‚Äù) ‚ãé arithmetize p)) := by
      rcases Rew.positive_iff.mp ht with ‚ü®t, rfl‚ü©
      apply oRing_consequence_of
      intro M _ _ _ _ _ mod
      haveI : T.Mod M := Theory.Mod.of_add_left M T ùêÑùê™
      haveI : ùêèùêÄ‚Åª.Mod M := Theory.Mod.of_provably_subtheory' M ùêèùêÄ‚Åª T
      simp [models_iff, Empty.eq_elim, polybound_bShift]
      intro e; constructor
      ¬∑ intro h x _; simpa [imp_iff_not_or] using h x
      ¬∑ intro h x hx
        exact Classical.or_iff_not_imp_left.mp (h x $ lt_of_lt_of_le hx (le_bound t Empty.elim e)) (by simpa using hx)
    exact Class.domain_eqvClosure
      (Class.BAll.ball (Class.Or.or (HClassIn.of_deltaZeroIn $ arithmetize_le_deltaZero _ _) ih) (polybound_positive ht)) this.symm
  case bex p t ht _ ih =>
    have : arithmetize ‚Äú‚àÉ[#0 < !!t] !p‚Äù ‚Üî[T + ùêÑùê™] (‚àÉ[‚Äú#0 < !!(polybound t)‚Äù] (arithmetize (‚Äú#0 < !!t‚Äù) ‚ãè arithmetize p)) := by
      rcases Rew.positive_iff.mp ht with ‚ü®t, rfl‚ü©
      apply oRing_consequence_of
      intro M _ _ _ _ _ mod
      haveI : T.Mod M := Theory.Mod.of_add_left M T ùêÑùê™
      haveI : ùêèùêÄ‚Åª.Mod M := Theory.Mod.of_provably_subtheory' M ùêèùêÄ‚Åª T
      simp [models_iff, Empty.eq_elim, polybound_bShift]
      intro e; constructor
      ¬∑ rintro ‚ü®x, hx, hp‚ü©
        exact ‚ü®x, lt_of_lt_of_le hx (le_bound t Empty.elim e), hx, hp‚ü©
      ¬∑ rintro ‚ü®x, _, hx, hp‚ü©; exact ‚ü®x, hx, hp‚ü©
    exact Class.domain_eqvClosure
      (Class.BEx.bex (Class.And.and (HClassIn.of_deltaZeroIn $ arithmetize_lt_deltaZero _ _) ih) (polybound_positive ht)) this.symm
  case all p _ ih => exact HClassIn.all ih
  case ex p _ ih => exact HClassIn.ex ih
  case pi p _ ih => exact HClassIn.pi ih
  case sigma p _ ih => exact HClassIn.sigma ih
  case dummy_pi p _ ih => exact HClassIn.dummy_pi ih
  case dummy_sigma p _ ih => exact HClassIn.dummy_sigma ih

lemma arithmetize_hClassIn {p : Semisentence ‚Ñí‚Çí·µ£[T] n} (hp : Œì·¥¥'(s)[T].Domain p) :
    Œì·¥¥(s)[T].Domain (arithmetize p) := by
  rcases hp with ‚ü®p', hp', H‚ü©
  exact Class.domain_eqvClosure (arithmetize_hClassIn_of_hierarchy hp') (by
    apply oRing_consequence_of
    intro M _ _ _ _ _ mod
    haveI : T.Mod M := Theory.Mod.of_add_left M T ùêÑùê™
    haveI : ùêèùêÄ‚Åª.Mod M := Theory.Mod.of_provably_subtheory' M ùêèùêÄ‚Åª T
    have : M ‚äß‚Çò (‚àÄ·∂†* ‚àÄ* (p' ‚ü∑ p)) := consequence_iff.mp H M (by simp [Theory.add_def, Theory.Mod.modelsTheory])
    simp [models_iff, Empty.eq_elim] at this ‚ä¢; intro e; exact this e)

lemma arithmetize_deltaZero {p : Semisentence ‚Ñí‚Çí·µ£[T] n} (hp : Œî‚ÇÄ'[T].Domain p) :
    Œî‚ÇÄ[T].Domain (arithmetize p) := arithmetize_hClassIn hp

end boundedLanguage

abbrev HSemiformulaIn (T : Theory ‚Ñí‚Çí·µ£) (Œì : Polarity) (s : ‚Ñï) (Œæ : Type*) [DecidableEq Œæ] (n : ‚Ñï) : Type _ :=
  { p : Semiformula ‚Ñí‚Çí·µ£ Œæ n // Œì·¥¥(s)[T].Domain p }

abbrev HSemisentenceIn (T : Theory ‚Ñí‚Çí·µ£) (Œì : Polarity) (s : ‚Ñï) (n : ‚Ñï) : Type _ := HSemiformulaIn T Œì s Empty n

abbrev HSemiformulaŒî‚ÇÄIn (T : Theory ‚Ñí‚Çí·µ£) (Œæ : Type*) [DecidableEq Œæ] (n : ‚Ñï) : Type _ := HSemiformulaIn T Œ£ 0 Œæ n

abbrev HSemisentenceŒî‚ÇÄIn (T : Theory ‚Ñí‚Çí·µ£) (n : ‚Ñï) : Type _ := HSemiformulaŒî‚ÇÄIn T Empty n

abbrev BSemiformula (T : Theory ‚Ñí‚Çí·µ£) (Œì : Polarity) (s : ‚Ñï) (Œæ : Type*) [DecidableEq Œæ] (n : ‚Ñï) : Type _ :=
  { p : Semiformula ‚Ñí‚Çí·µ£[T] Œæ n // Œì·¥¥'(s)[T].Domain p }

abbrev BSemisentence (T : Theory ‚Ñí‚Çí·µ£) (Œì : Polarity) (s : ‚Ñï) (n : ‚Ñï) : Type _ := BSemiformula T Œì s Empty n

abbrev BSemiformulaŒî‚ÇÄ (T : Theory ‚Ñí‚Çí·µ£) (Œæ : Type*) [DecidableEq Œæ] (n : ‚Ñï) : Type _ :=
  { p : Semiformula ‚Ñí‚Çí·µ£[T] Œæ n // Œî‚ÇÄ'[T].Domain p }

abbrev BSemisentenceŒî‚ÇÄ (T : Theory ‚Ñí‚Çí·µ£) (n : ‚Ñï) : Type _ := BSemiformulaŒî‚ÇÄ T Empty n

namespace BSemiformula

variable {Œì : Polarity} {s : ‚Ñï} {T : Theory ‚Ñí‚Çí·µ£} {Œæ : Type*} [DecidableEq Œæ] {n : ‚Ñï}

@[simp] lemma hClassInBL_val (p : BSemiformula T Œì s Œæ n) : Œì·¥¥'(s)[T].Domain p.val := p.property

@[simp] lemma deltaZeroInBL_val (p : BSemiformulaŒî‚ÇÄ T Œæ n) : Œî‚ÇÄ'[T].Domain p.val := p.property

end BSemiformula

open boundedLanguage

variable {T : Theory ‚Ñí‚Çí·µ£} [ùêèùêÄ‚Åª ‚âæ T]

def toDeltaZeroRelation (œÉ : Semisentence ‚Ñí‚Çí·µ£[T] k)
    (hœÉ : Œî‚ÇÄ'[T].Domain œÉ) : DeltaZeroRelation T k where
  definition := arithmetize œÉ
  definition_deltaZero := arithmetize_deltaZero hœÉ

def toBoundedDeltaZeroFunction (œÉ : Semisentence ‚Ñí‚Çí·µ£[T] (k + 1))
    (hœÉ : Œî‚ÇÄ'[T].Domain œÉ)
    (total : T + ùêÑùê™ ‚ä¢! ‚àÄ* ‚àÉ! arithmetize œÉ)
    (bound : Polynomial k)
    (bounded : T + ùêèùêÄ‚Åª + ùêÑùê™ ‚ä¢! ‚àÄ* ‚Äú!(arithmetize œÉ) ‚Üí #0 ‚â§ !!(Rew.bShift bound)‚Äù) : BoundedDeltaZeroFunction T k where
  function := ‚ü®toDeltaZeroRelation œÉ hœÉ, total‚ü©
  bound := bound
  bounded := by simpa [DeltaZeroFunction.definition, toDeltaZeroRelation]

section semantics

variable {M : Type} [Zero M] [One M] [Add M] [Mul M] [LT M] [T.Mod M]

variable {œÉ : Semisentence ‚Ñí‚Çí·µ£[T] (k + 1)}
    {hœÉ : Œî‚ÇÄ'[T].Domain œÉ}
    {total : T + ùêÑùê™ ‚ä¢! ‚àÄ* ‚àÉ! arithmetize œÉ}
    {bound : Polynomial k}
    {bounded : T + ùêèùêÄ‚Åª + ùêÑùê™ ‚ä¢! ‚àÄ* ‚Äú!(arithmetize œÉ) ‚Üí #0 ‚â§ !!(Rew.bShift bound)‚Äù}

lemma toBoundedDeltaZeroFunction_realize_iff {a : M} {v : Fin k ‚Üí M} :
    a = (toBoundedDeltaZeroFunction œÉ hœÉ total bound bounded).realize v ‚Üî Semiformula.PVal! M (a :> v) œÉ := by
  haveI : ùêèùêÄ‚Åª.Mod M := Theory.Mod.of_provably_subtheory' M _ T
  simp [DeltaZeroFunction.realize_graph, toBoundedDeltaZeroFunction, toDeltaZeroRelation, DeltaZeroFunction.definition]

lemma toBoundedDeltaZeroFunction_realize_iff' {v : Fin (k + 1) ‚Üí M} :
    Semiformula.PVal! M v œÉ ‚Üî v 0 = (toBoundedDeltaZeroFunction œÉ hœÉ total bound bounded).realize (v ¬∑.succ) := by
  simp [toBoundedDeltaZeroFunction_realize_iff, Matrix.eq_vecCons']

end semantics

end Definability

end Arith

end LO.FirstOrder
